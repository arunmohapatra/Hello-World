import java.nio.file.*;
import java.io.IOException;
import java.util.*;

public class day7 {
    public static void main(String[] args) throws IOException {
        List<String> lines = Files.readAllLines(Path.of("D:\\input.txt"));
        if (lines.isEmpty()) {
            System.err.println("input.txt is empty");
            return;
        }

        int rows = lines.size();
        int cols = lines.get(0).length();
        char[][] grid = new char[rows][cols];

        int sRow = -1, sCol = -1;
        for (int r = 0; r < rows; r++) {
            String line = lines.get(r);
            // allow variable-length lines by padding with '.' if necessary
            if (line.length() < cols) line = String.format("%-" + cols + "s", line).replace(' ', '.');
            for (int c = 0; c < cols; c++) {
                grid[r][c] = line.charAt(c);
                if (grid[r][c] == 'S') {
                    sRow = r;
                    sCol = c;
                }
            }
        }

        if (sRow == -1) {
            System.err.println("No 'S' start found in input.txt");
            return;
        }

        long splitCount = 0L;

        // initial beams enter the row below S (if any)
        int startRow = sRow + 1;
        Set<Integer> active = new HashSet<>();
        if (startRow < rows) active.add(sCol);

        // process each row from startRow to last row
        for (int r = startRow; r < rows; r++) {
            if (active.isEmpty()) {
                // no beams entering this row
                continue;
            }

            Set<Integer> nextRow = new HashSet<>();            // beams that will enter row r+1
            Set<Integer> processedThisRow = new HashSet<>();   // to avoid re-processing same column twice
            Deque<Integer> queue = new ArrayDeque<>(active);   // BFS-like processing for same-row generation

            while (!queue.isEmpty()) {
                int c = queue.poll();
                if (c < 0 || c >= cols) continue;
                if (!processedThisRow.add(c)) continue; // already handled this column this row

                char cell = grid[r][c];
                if (cell == '^') {
                    // beam encountered a splitter: it stops and emits new beams left & right at the SAME row
                    splitCount++;
                    int left = c - 1;
                    int right = c + 1;
                    if (left >= 0 && !processedThisRow.contains(left)) queue.add(left);
                    if (right < cols && !processedThisRow.contains(right)) queue.add(right);
                    // do NOT add to nextRow (beam stops)
                } else {
                    // passes through ('.' or 'S' or any other non-split symbol) => continues downward
                    nextRow.add(c);
                }
            }

            // move to next row: beams that survived to next row
            active = nextRow;
        }

        System.out.println(splitCount);
    }
}
